
# üèóÔ∏è Project Architecture & Decisions

This document outlines the architectural decisions, patterns, and technologies used in **{{ProjectName}}**. It serves as a guide for developers to understand the "Why" and "How" of the codebase.

---

## üõ†Ô∏è Tech Stack Strategy
- **Framework**: .NET 8 (LTS) for stability and performance.
- **Language**: C# 12
- **Database**: Entity Framework Core 8 (Code-First)
- **API**: ASP.NET Core Web API (Controllers)

## üèõÔ∏è Clean Architecture Layers
The solution follows the **Clean Architecture** principles to ensure separation of concerns and testability.

### 1. **Domain Layer** (`{{ProjectName}}.Domain`)
- **Role**: The core of the application. Contains enterprise logic and types.
- **Dependencies**: None. Pure C#.
- **Key Components**:
  - **Entities**: Mutable objects with identity (e.g., `BaseEntity`).
  - **Value Objects**: Immutable objects defined by their attributes.
  - **Enums & Constants**: Shared domain values.
  - **Exceptions**: Domain-specific error types.

### 2. **Application Layer** (`{{ProjectName}}.Application`)
- **Role**: Orchestrates application logic and use cases.
- **Dependencies**: Depends on `Domain`.
- **Patterns**:
  - **CQRS**: Implemented via **MediatR**. Separates Read (Queries) from Write (Commands) operations.
  - **Validation**: **FluentValidation** used for request model validation behaviors.
  - **Mapping**: Entity <-> DTO mapping (Manual or generic).
  - **Interfaces**: Defines contracts for infrastructure (e.g., `IApplicationDbContext`).

### 3. **Infrastructure Layer** (`{{ProjectName}}.Infrastructure`)
- **Role**: Implements interfaces defined in `Application`. Handles external concerns.
- **Dependencies**: Depends on `Application`.
- **Key Components**:
  - **Persistence**: `{{DbContextName}}` (EF Core) implementation.
  - **Configuration**: `appsettings.json` binding.
  - **Services**: Email, Identity, System Clock, etc.

### 4. **Web API Layer** (`{{ProjectName}}.WebAPI`)
- **Role**: The entry point. Handles HTTP requests and responses.
- **Dependencies**: Depends on `Application` and `Infrastructure`.
- **Key Components**:
  - **Controllers**: Thin wrappers sending commands/queries to MediatR.
  - **Middleware**: Global Exception Handling, Logging (Serilog).
  - **Swagger/OpenAPI**: Automatic API documentation.
  - **Formatters**: JSON standard response structures.

---

## ‚ùì Architectural Decisions (ADR)

### Why MediatR?
We use MediatR to decouple the API layer from the Application logic. Controllers simply send a message and await a response, enforcing the **Single Responsibility Principle**.

### Why FluentValidation?
Validation rules are business logic. They belong in the Application layer, not in the Controller attributes. We use a MediatR Pipeline Behavior to auto-validate all commands before they reach the handler.

### Authentication & Authorization
- **Mechanism**: JWT (JSON Web Tokens).
- **Flow**: Stateless authentication.
- **Identity**: Custom or ASP.NET Core Identity (configurable).

### Database Strategy
- **ORM**: EF Core for productivity.
- **Migrations**: Code-first migrations managed in `Infrastructure`.

---

## ‚úÖ Development Checklist (ToDo)

- [ ] **Define Entities**: Add your business entities in `Domain`.
- [ ] **Create Use Cases**: Add Command/Query handlers in `Application`.
- [ ] **Setup Database**: Update connection string in `appsettings.json` and run `dotnet ef database update`.
- [ ] **Write Tests**: Create Unit and Integration tests (xUnit recommended).

---

*Generated by [IonCLI](https://github.com/YourRepo/IonCLI)*
